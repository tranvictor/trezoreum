// Code generated by protoc-gen-go. DO NOT EDIT.
// source: messages-crypto.proto

/*
Package messages_crypto is a generated protocol buffer package.

It is generated from these files:
	messages-crypto.proto

It has these top-level messages:
	CipherKeyValue
	CipheredKeyValue
	IdentityType
	SignIdentity
	SignedIdentity
	GetECDHSessionKey
	ECDHSessionKey
	CosiCommit
	CosiCommitment
	CosiSign
	CosiSignature
*/
package messages_crypto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Request: Ask device to encrypt or decrypt value of given key
// @start
// @next CipheredKeyValue
// @next Failure
type CipherKeyValue struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Key              *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value            []byte   `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Encrypt          *bool    `protobuf:"varint,4,opt,name=encrypt" json:"encrypt,omitempty"`
	AskOnEncrypt     *bool    `protobuf:"varint,5,opt,name=ask_on_encrypt,json=askOnEncrypt" json:"ask_on_encrypt,omitempty"`
	AskOnDecrypt     *bool    `protobuf:"varint,6,opt,name=ask_on_decrypt,json=askOnDecrypt" json:"ask_on_decrypt,omitempty"`
	Iv               []byte   `protobuf:"bytes,7,opt,name=iv" json:"iv,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CipherKeyValue) Reset()                    { *m = CipherKeyValue{} }
func (m *CipherKeyValue) String() string            { return proto.CompactTextString(m) }
func (*CipherKeyValue) ProtoMessage()               {}
func (*CipherKeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CipherKeyValue) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *CipherKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *CipherKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CipherKeyValue) GetEncrypt() bool {
	if m != nil && m.Encrypt != nil {
		return *m.Encrypt
	}
	return false
}

func (m *CipherKeyValue) GetAskOnEncrypt() bool {
	if m != nil && m.AskOnEncrypt != nil {
		return *m.AskOnEncrypt
	}
	return false
}

func (m *CipherKeyValue) GetAskOnDecrypt() bool {
	if m != nil && m.AskOnDecrypt != nil {
		return *m.AskOnDecrypt
	}
	return false
}

func (m *CipherKeyValue) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

// *
// Response: Return ciphered/deciphered value
// @end
type CipheredKeyValue struct {
	Value            []byte `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CipheredKeyValue) Reset()                    { *m = CipheredKeyValue{} }
func (m *CipheredKeyValue) String() string            { return proto.CompactTextString(m) }
func (*CipheredKeyValue) ProtoMessage()               {}
func (*CipheredKeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CipheredKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// *
// Structure representing identity data
// @embed
type IdentityType struct {
	Proto            *string `protobuf:"bytes,1,opt,name=proto" json:"proto,omitempty"`
	User             *string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Host             *string `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Port             *string `protobuf:"bytes,4,opt,name=port" json:"port,omitempty"`
	Path             *string `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
	Index            *uint32 `protobuf:"varint,6,opt,name=index,def=0" json:"index,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *IdentityType) Reset()                    { *m = IdentityType{} }
func (m *IdentityType) String() string            { return proto.CompactTextString(m) }
func (*IdentityType) ProtoMessage()               {}
func (*IdentityType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

const Default_IdentityType_Index uint32 = 0

func (m *IdentityType) GetProto() string {
	if m != nil && m.Proto != nil {
		return *m.Proto
	}
	return ""
}

func (m *IdentityType) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *IdentityType) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *IdentityType) GetPort() string {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return ""
}

func (m *IdentityType) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *IdentityType) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return Default_IdentityType_Index
}

// *
// Request: Ask device to sign identity
// @start
// @next SignedIdentity
// @next Failure
type SignIdentity struct {
	Identity         *IdentityType `protobuf:"bytes,1,opt,name=identity" json:"identity,omitempty"`
	ChallengeHidden  []byte        `protobuf:"bytes,2,opt,name=challenge_hidden,json=challengeHidden" json:"challenge_hidden,omitempty"`
	ChallengeVisual  *string       `protobuf:"bytes,3,opt,name=challenge_visual,json=challengeVisual" json:"challenge_visual,omitempty"`
	EcdsaCurveName   *string       `protobuf:"bytes,4,opt,name=ecdsa_curve_name,json=ecdsaCurveName" json:"ecdsa_curve_name,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *SignIdentity) Reset()                    { *m = SignIdentity{} }
func (m *SignIdentity) String() string            { return proto.CompactTextString(m) }
func (*SignIdentity) ProtoMessage()               {}
func (*SignIdentity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SignIdentity) GetIdentity() *IdentityType {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *SignIdentity) GetChallengeHidden() []byte {
	if m != nil {
		return m.ChallengeHidden
	}
	return nil
}

func (m *SignIdentity) GetChallengeVisual() string {
	if m != nil && m.ChallengeVisual != nil {
		return *m.ChallengeVisual
	}
	return ""
}

func (m *SignIdentity) GetEcdsaCurveName() string {
	if m != nil && m.EcdsaCurveName != nil {
		return *m.EcdsaCurveName
	}
	return ""
}

// *
// Response: Device provides signed identity
// @end
type SignedIdentity struct {
	Address          *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	PublicKey        []byte  `protobuf:"bytes,2,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	Signature        []byte  `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SignedIdentity) Reset()                    { *m = SignedIdentity{} }
func (m *SignedIdentity) String() string            { return proto.CompactTextString(m) }
func (*SignedIdentity) ProtoMessage()               {}
func (*SignedIdentity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SignedIdentity) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *SignedIdentity) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *SignedIdentity) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// *
// Request: Ask device to generate ECDH session key
// @start
// @next ECDHSessionKey
// @next Failure
type GetECDHSessionKey struct {
	Identity         *IdentityType `protobuf:"bytes,1,opt,name=identity" json:"identity,omitempty"`
	PeerPublicKey    []byte        `protobuf:"bytes,2,opt,name=peer_public_key,json=peerPublicKey" json:"peer_public_key,omitempty"`
	EcdsaCurveName   *string       `protobuf:"bytes,3,opt,name=ecdsa_curve_name,json=ecdsaCurveName" json:"ecdsa_curve_name,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *GetECDHSessionKey) Reset()                    { *m = GetECDHSessionKey{} }
func (m *GetECDHSessionKey) String() string            { return proto.CompactTextString(m) }
func (*GetECDHSessionKey) ProtoMessage()               {}
func (*GetECDHSessionKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetECDHSessionKey) GetIdentity() *IdentityType {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *GetECDHSessionKey) GetPeerPublicKey() []byte {
	if m != nil {
		return m.PeerPublicKey
	}
	return nil
}

func (m *GetECDHSessionKey) GetEcdsaCurveName() string {
	if m != nil && m.EcdsaCurveName != nil {
		return *m.EcdsaCurveName
	}
	return ""
}

// *
// Response: Device provides ECDH session key
// @end
type ECDHSessionKey struct {
	SessionKey       []byte `protobuf:"bytes,1,opt,name=session_key,json=sessionKey" json:"session_key,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ECDHSessionKey) Reset()                    { *m = ECDHSessionKey{} }
func (m *ECDHSessionKey) String() string            { return proto.CompactTextString(m) }
func (*ECDHSessionKey) ProtoMessage()               {}
func (*ECDHSessionKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ECDHSessionKey) GetSessionKey() []byte {
	if m != nil {
		return m.SessionKey
	}
	return nil
}

// *
// Request: Ask device to commit to CoSi signing
// @start
// @next CosiCommitment
// @next Failure
type CosiCommit struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Data             []byte   `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CosiCommit) Reset()                    { *m = CosiCommit{} }
func (m *CosiCommit) String() string            { return proto.CompactTextString(m) }
func (*CosiCommit) ProtoMessage()               {}
func (*CosiCommit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CosiCommit) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *CosiCommit) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Response: Contains a CoSi commitment
// @end
type CosiCommitment struct {
	Commitment       []byte `protobuf:"bytes,1,opt,name=commitment" json:"commitment,omitempty"`
	Pubkey           []byte `protobuf:"bytes,2,opt,name=pubkey" json:"pubkey,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CosiCommitment) Reset()                    { *m = CosiCommitment{} }
func (m *CosiCommitment) String() string            { return proto.CompactTextString(m) }
func (*CosiCommitment) ProtoMessage()               {}
func (*CosiCommitment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CosiCommitment) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *CosiCommitment) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

// *
// Request: Ask device to sign using CoSi
// @start
// @next CosiSignature
// @next Failure
type CosiSign struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Data             []byte   `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	GlobalCommitment []byte   `protobuf:"bytes,3,opt,name=global_commitment,json=globalCommitment" json:"global_commitment,omitempty"`
	GlobalPubkey     []byte   `protobuf:"bytes,4,opt,name=global_pubkey,json=globalPubkey" json:"global_pubkey,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CosiSign) Reset()                    { *m = CosiSign{} }
func (m *CosiSign) String() string            { return proto.CompactTextString(m) }
func (*CosiSign) ProtoMessage()               {}
func (*CosiSign) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CosiSign) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *CosiSign) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CosiSign) GetGlobalCommitment() []byte {
	if m != nil {
		return m.GlobalCommitment
	}
	return nil
}

func (m *CosiSign) GetGlobalPubkey() []byte {
	if m != nil {
		return m.GlobalPubkey
	}
	return nil
}

// *
// Response: Contains a CoSi signature
// @end
type CosiSignature struct {
	Signature        []byte `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CosiSignature) Reset()                    { *m = CosiSignature{} }
func (m *CosiSignature) String() string            { return proto.CompactTextString(m) }
func (*CosiSignature) ProtoMessage()               {}
func (*CosiSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CosiSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterType((*CipherKeyValue)(nil), "CipherKeyValue")
	proto.RegisterType((*CipheredKeyValue)(nil), "CipheredKeyValue")
	proto.RegisterType((*IdentityType)(nil), "IdentityType")
	proto.RegisterType((*SignIdentity)(nil), "SignIdentity")
	proto.RegisterType((*SignedIdentity)(nil), "SignedIdentity")
	proto.RegisterType((*GetECDHSessionKey)(nil), "GetECDHSessionKey")
	proto.RegisterType((*ECDHSessionKey)(nil), "ECDHSessionKey")
	proto.RegisterType((*CosiCommit)(nil), "CosiCommit")
	proto.RegisterType((*CosiCommitment)(nil), "CosiCommitment")
	proto.RegisterType((*CosiSign)(nil), "CosiSign")
	proto.RegisterType((*CosiSignature)(nil), "CosiSignature")
}

func init() { proto.RegisterFile("messages-crypto.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0xdd, 0x6a, 0xdb, 0x30,
	0x14, 0xc7, 0x71, 0x93, 0xb6, 0xf1, 0xa9, 0xe3, 0xa6, 0xda, 0x97, 0x61, 0x5f, 0xc1, 0x1d, 0x23,
	0x65, 0x34, 0x6c, 0xbb, 0x2c, 0xec, 0xa6, 0x69, 0x59, 0x47, 0x59, 0x57, 0xdc, 0xd2, 0x5b, 0xa3,
	0xd8, 0x67, 0xb1, 0xa8, 0x2d, 0x19, 0x4b, 0x0e, 0xcb, 0xde, 0x61, 0xb0, 0xd7, 0xd9, 0x33, 0xec,
	0xa5, 0x86, 0x25, 0xdb, 0x49, 0x3f, 0x18, 0xf4, 0xee, 0x9c, 0xbf, 0xff, 0xb6, 0x7e, 0x7f, 0xe9,
	0x58, 0xf0, 0x24, 0x43, 0x29, 0xe9, 0x0c, 0xe5, 0x7e, 0x54, 0x2c, 0x72, 0x25, 0xc6, 0x79, 0x21,
	0x94, 0xf0, 0xff, 0x5a, 0xe0, 0x4e, 0x58, 0x9e, 0x60, 0x71, 0x8a, 0x8b, 0x2b, 0x9a, 0x96, 0x48,
	0x9e, 0x83, 0x4d, 0xe3, 0xb8, 0x40, 0x29, 0x43, 0xee, 0x59, 0xc3, 0xce, 0xa8, 0x1f, 0xf4, 0x6a,
	0xe1, 0x8c, 0x0c, 0xa0, 0x73, 0x8d, 0x0b, 0x6f, 0x6d, 0x68, 0x8d, 0xec, 0xa0, 0x2a, 0xc9, 0x63,
	0x58, 0x9f, 0x57, 0xef, 0x79, 0x9d, 0xa1, 0x35, 0x72, 0x02, 0xd3, 0x10, 0x0f, 0x36, 0x91, 0xeb,
	0x95, 0xbc, 0xee, 0xd0, 0x1a, 0xf5, 0x82, 0xa6, 0x25, 0x6f, 0xc0, 0xa5, 0xf2, 0x3a, 0x14, 0x3c,
	0x6c, 0x0c, 0xeb, 0xda, 0xe0, 0x50, 0x79, 0xfd, 0x8d, 0x1f, 0xdf, 0x71, 0xc5, 0x68, 0x5c, 0x1b,
	0x2b, 0xae, 0x23, 0xa3, 0x11, 0x17, 0xd6, 0xd8, 0xdc, 0xdb, 0xd4, 0x0b, 0xaf, 0xb1, 0xb9, 0x3f,
	0x82, 0x81, 0x09, 0x83, 0x71, 0x1b, 0xa7, 0xe5, 0xb3, 0x56, 0xf8, 0xfc, 0x5f, 0x16, 0x38, 0x5f,
	0x62, 0xe4, 0x8a, 0xa9, 0xc5, 0xe5, 0x22, 0xd7, 0x36, 0xbd, 0x23, 0xda, 0x66, 0x07, 0xa6, 0x21,
	0x04, 0xba, 0xa5, 0xc4, 0xa2, 0xce, 0xab, 0xeb, 0x4a, 0x4b, 0x84, 0x54, 0x3a, 0xaf, 0x1d, 0xe8,
	0xba, 0xd2, 0x72, 0x51, 0x98, 0xac, 0x76, 0xa0, 0x6b, 0xad, 0x51, 0x95, 0xe8, 0x78, 0x95, 0x46,
	0x55, 0x42, 0x9e, 0xc1, 0x3a, 0xe3, 0x31, 0xfe, 0xd0, 0x69, 0xfa, 0x07, 0xd6, 0xfb, 0xc0, 0xf4,
	0xfe, 0x1f, 0x0b, 0x9c, 0x0b, 0x36, 0xe3, 0x0d, 0x13, 0xd9, 0x83, 0x1e, 0xab, 0x6b, 0x8d, 0xb4,
	0xf5, 0xb1, 0x3f, 0x5e, 0x05, 0x0e, 0xda, 0xc7, 0x64, 0x0f, 0x06, 0x51, 0x42, 0xd3, 0x14, 0xf9,
	0x0c, 0xc3, 0x84, 0xc5, 0x31, 0x72, 0x0d, 0xec, 0x04, 0xdb, 0xad, 0x7e, 0xa2, 0xe5, 0x9b, 0xd6,
	0x39, 0x93, 0x25, 0x4d, 0xeb, 0x1c, 0x4b, 0xeb, 0x95, 0x96, 0xc9, 0x08, 0x06, 0x18, 0xc5, 0x92,
	0x86, 0x51, 0x59, 0xcc, 0x31, 0xe4, 0x34, 0xc3, 0x3a, 0x9e, 0xab, 0xf5, 0x49, 0x25, 0x9f, 0xd1,
	0x0c, 0xfd, 0x19, 0xb8, 0x15, 0x3a, 0xc6, 0x2d, 0xbc, 0x07, 0x9b, 0xf5, 0xc4, 0xd4, 0xdb, 0xd9,
	0xb4, 0xe4, 0x25, 0x40, 0x5e, 0x4e, 0x53, 0x16, 0x85, 0xcd, 0x18, 0x39, 0x81, 0x6d, 0x94, 0x53,
	0x5c, 0x90, 0x17, 0x60, 0x4b, 0x36, 0xe3, 0x54, 0x95, 0x45, 0x33, 0x50, 0x4b, 0xc1, 0xff, 0x6d,
	0xc1, 0xce, 0x67, 0x54, 0xc7, 0x93, 0xa3, 0x93, 0x0b, 0x94, 0x92, 0x09, 0x5e, 0xbd, 0xf3, 0x80,
	0x9d, 0x7a, 0x0b, 0xdb, 0x39, 0x62, 0x11, 0xde, 0x41, 0xe8, 0x57, 0xf2, 0x79, 0x8b, 0x71, 0x5f,
	0xf6, 0xce, 0xbd, 0xd9, 0x3f, 0x80, 0x7b, 0x0b, 0xe7, 0x35, 0x6c, 0x49, 0xd3, 0xe9, 0xef, 0x9b,
	0xa9, 0x03, 0xd9, 0x1a, 0xfc, 0x4f, 0x00, 0x13, 0x21, 0xd9, 0x44, 0x64, 0x19, 0x53, 0xff, 0xff,
	0xdb, 0x08, 0x74, 0x63, 0xaa, 0x68, 0x0d, 0xa9, 0x6b, 0xff, 0x04, 0xdc, 0xe5, 0xeb, 0x19, 0x72,
	0x45, 0x5e, 0x01, 0x44, 0x6d, 0xd7, 0x2c, 0xb8, 0x54, 0xc8, 0x53, 0xd8, 0xc8, 0xcb, 0xe9, 0x32,
	0x6c, 0xdd, 0x55, 0xff, 0x40, 0xaf, 0xfa, 0x54, 0x75, 0x78, 0x0f, 0xe6, 0x20, 0xef, 0x60, 0x67,
	0x96, 0x8a, 0x29, 0x4d, 0xc3, 0x95, 0xc5, 0xcd, 0x91, 0x0d, 0xcc, 0x83, 0x15, 0xc4, 0x5d, 0xe8,
	0xd7, 0xe6, 0x9a, 0xa4, 0xab, 0x8d, 0x8e, 0x11, 0xcf, 0x0d, 0xcf, 0x3e, 0xf4, 0x1b, 0x1c, 0x7d,
	0xde, 0x37, 0xa7, 0xc1, 0xba, 0x35, 0x0d, 0x87, 0x07, 0xb0, 0x1b, 0x89, 0x6c, 0x2c, 0xa9, 0x12,
	0x32, 0x61, 0x29, 0x9d, 0xca, 0xb1, 0x2a, 0xf0, 0xa7, 0x28, 0xc6, 0x29, 0x9b, 0x9a, 0xeb, 0x6d,
	0x5a, 0x7e, 0x3f, 0x7c, 0x74, 0xa9, 0xc5, 0xaf, 0xe6, 0xfa, 0x9b, 0xe8, 0xcb, 0xef, 0x5f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xf1, 0xf3, 0xd4, 0xc3, 0x0e, 0x05, 0x00, 0x00,
}
