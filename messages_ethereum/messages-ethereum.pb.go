// Code generated by protoc-gen-go. DO NOT EDIT.
// source: messages-ethereum.proto

/*
Package hw_trezor_messages_ethereum is a generated protocol buffer package.

It is generated from these files:
	messages-ethereum.proto

It has these top-level messages:
	EthereumGetPublicKey
	EthereumPublicKey
	EthereumGetAddress
	EthereumAddress
	EthereumSignTx
	EthereumTxRequest
	EthereumTxAck
	EthereumSignMessage
	EthereumMessageSignature
	EthereumVerifyMessage
*/
package messages_ethereum

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import hw_trezor_messages_common "github.com/tranvictor/trezoreum/messages_common"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Request: Ask device for public key corresponding to address_n path
// @start
// @next EthereumPublicKey
// @next Failure
type EthereumGetPublicKey struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	ShowDisplay      *bool    `protobuf:"varint,2,opt,name=show_display,json=showDisplay" json:"show_display,omitempty"`
	ChainId          *uint32  `protobuf:"varint,3,opt,name=chain_id,json=chainId" json:"chain_id,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EthereumGetPublicKey) Reset()                    { *m = EthereumGetPublicKey{} }
func (m *EthereumGetPublicKey) String() string            { return proto.CompactTextString(m) }
func (*EthereumGetPublicKey) ProtoMessage()               {}
func (*EthereumGetPublicKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EthereumGetPublicKey) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EthereumGetPublicKey) GetShowDisplay() bool {
	if m != nil && m.ShowDisplay != nil {
		return *m.ShowDisplay
	}
	return false
}

func (m *EthereumGetPublicKey) GetChainId() uint32 {
	if m != nil && m.ChainId != nil {
		return *m.ChainId
	}
	return 0
}

// *
// Response: Contains public key derived from device private seed
// @end
type EthereumPublicKey struct {
	Node             *hw_trezor_messages_common.HDNodeType `protobuf:"bytes,1,req,name=node" json:"node,omitempty"`
	Xpub             *string                               `protobuf:"bytes,2,opt,name=xpub" json:"xpub,omitempty"`
	XXX_unrecognized []byte                                `json:"-"`
}

func (m *EthereumPublicKey) Reset()                    { *m = EthereumPublicKey{} }
func (m *EthereumPublicKey) String() string            { return proto.CompactTextString(m) }
func (*EthereumPublicKey) ProtoMessage()               {}
func (*EthereumPublicKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EthereumPublicKey) GetNode() *hw_trezor_messages_common.HDNodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *EthereumPublicKey) GetXpub() string {
	if m != nil && m.Xpub != nil {
		return *m.Xpub
	}
	return ""
}

// *
// Request: Ask device for Ethereum address corresponding to address_n path
// @start
// @next EthereumAddress
// @next Failure
type EthereumGetAddress struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	ShowDisplay      *bool    `protobuf:"varint,2,opt,name=show_display,json=showDisplay" json:"show_display,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EthereumGetAddress) Reset()                    { *m = EthereumGetAddress{} }
func (m *EthereumGetAddress) String() string            { return proto.CompactTextString(m) }
func (*EthereumGetAddress) ProtoMessage()               {}
func (*EthereumGetAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EthereumGetAddress) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EthereumGetAddress) GetShowDisplay() bool {
	if m != nil && m.ShowDisplay != nil {
		return *m.ShowDisplay
	}
	return false
}

// *
// Response: Contains an Ethereum address derived from device private seed
// @end
type EthereumAddress struct {
	Address          []byte `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EthereumAddress) Reset()                    { *m = EthereumAddress{} }
func (m *EthereumAddress) String() string            { return proto.CompactTextString(m) }
func (*EthereumAddress) ProtoMessage()               {}
func (*EthereumAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EthereumAddress) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

// *
// Request: Ask device to sign transaction
// All fields are optional from the protocol's point of view. Each field defaults to value `0` if missing.
// Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.
// @start
// @next EthereumTxRequest
// @next Failure
type EthereumSignTx struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Nonce            []byte   `protobuf:"bytes,2,opt,name=nonce" json:"nonce,omitempty"`
	GasPrice         []byte   `protobuf:"bytes,3,opt,name=gas_price,json=gasPrice" json:"gas_price,omitempty"`
	GasLimit         []byte   `protobuf:"bytes,4,opt,name=gas_limit,json=gasLimit" json:"gas_limit,omitempty"`
	To               []byte   `protobuf:"bytes,5,opt,name=to" json:"to,omitempty"`
	Value            []byte   `protobuf:"bytes,6,opt,name=value" json:"value,omitempty"`
	DataInitialChunk []byte   `protobuf:"bytes,7,opt,name=data_initial_chunk,json=dataInitialChunk" json:"data_initial_chunk,omitempty"`
	DataLength       *uint32  `protobuf:"varint,8,opt,name=data_length,json=dataLength" json:"data_length,omitempty"`
	ChainId          *uint32  `protobuf:"varint,9,opt,name=chain_id,json=chainId" json:"chain_id,omitempty"`
	TxType           *uint32  `protobuf:"varint,10,opt,name=tx_type,json=txType" json:"tx_type,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EthereumSignTx) Reset()                    { *m = EthereumSignTx{} }
func (m *EthereumSignTx) String() string            { return proto.CompactTextString(m) }
func (*EthereumSignTx) ProtoMessage()               {}
func (*EthereumSignTx) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *EthereumSignTx) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EthereumSignTx) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EthereumSignTx) GetGasPrice() []byte {
	if m != nil {
		return m.GasPrice
	}
	return nil
}

func (m *EthereumSignTx) GetGasLimit() []byte {
	if m != nil {
		return m.GasLimit
	}
	return nil
}

func (m *EthereumSignTx) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *EthereumSignTx) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *EthereumSignTx) GetDataInitialChunk() []byte {
	if m != nil {
		return m.DataInitialChunk
	}
	return nil
}

func (m *EthereumSignTx) GetDataLength() uint32 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *EthereumSignTx) GetChainId() uint32 {
	if m != nil && m.ChainId != nil {
		return *m.ChainId
	}
	return 0
}

func (m *EthereumSignTx) GetTxType() uint32 {
	if m != nil && m.TxType != nil {
		return *m.TxType
	}
	return 0
}

// *
// Response: Device asks for more data from transaction payload, or returns the signature.
// If data_length is set, device awaits that many more bytes of payload.
// Otherwise, the signature_* fields contain the computed transaction signature. All three fields will be present.
// @end
// @next EthereumTxAck
type EthereumTxRequest struct {
	DataLength       *uint32 `protobuf:"varint,1,opt,name=data_length,json=dataLength" json:"data_length,omitempty"`
	SignatureV       *uint32 `protobuf:"varint,2,opt,name=signature_v,json=signatureV" json:"signature_v,omitempty"`
	SignatureR       []byte  `protobuf:"bytes,3,opt,name=signature_r,json=signatureR" json:"signature_r,omitempty"`
	SignatureS       []byte  `protobuf:"bytes,4,opt,name=signature_s,json=signatureS" json:"signature_s,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EthereumTxRequest) Reset()                    { *m = EthereumTxRequest{} }
func (m *EthereumTxRequest) String() string            { return proto.CompactTextString(m) }
func (*EthereumTxRequest) ProtoMessage()               {}
func (*EthereumTxRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *EthereumTxRequest) GetDataLength() uint32 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *EthereumTxRequest) GetSignatureV() uint32 {
	if m != nil && m.SignatureV != nil {
		return *m.SignatureV
	}
	return 0
}

func (m *EthereumTxRequest) GetSignatureR() []byte {
	if m != nil {
		return m.SignatureR
	}
	return nil
}

func (m *EthereumTxRequest) GetSignatureS() []byte {
	if m != nil {
		return m.SignatureS
	}
	return nil
}

// *
// Request: Transaction payload data.
// @next EthereumTxRequest
type EthereumTxAck struct {
	DataChunk        []byte `protobuf:"bytes,1,opt,name=data_chunk,json=dataChunk" json:"data_chunk,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EthereumTxAck) Reset()                    { *m = EthereumTxAck{} }
func (m *EthereumTxAck) String() string            { return proto.CompactTextString(m) }
func (*EthereumTxAck) ProtoMessage()               {}
func (*EthereumTxAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *EthereumTxAck) GetDataChunk() []byte {
	if m != nil {
		return m.DataChunk
	}
	return nil
}

// *
// Request: Ask device to sign message
// @start
// @next EthereumMessageSignature
// @next Failure
type EthereumSignMessage struct {
	AddressN         []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Message          []byte   `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EthereumSignMessage) Reset()                    { *m = EthereumSignMessage{} }
func (m *EthereumSignMessage) String() string            { return proto.CompactTextString(m) }
func (*EthereumSignMessage) ProtoMessage()               {}
func (*EthereumSignMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *EthereumSignMessage) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *EthereumSignMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

// *
// Response: Signed message
// @end
type EthereumMessageSignature struct {
	Address          []byte `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Signature        []byte `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EthereumMessageSignature) Reset()                    { *m = EthereumMessageSignature{} }
func (m *EthereumMessageSignature) String() string            { return proto.CompactTextString(m) }
func (*EthereumMessageSignature) ProtoMessage()               {}
func (*EthereumMessageSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *EthereumMessageSignature) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *EthereumMessageSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// *
// Request: Ask device to verify message
// @start
// @next Success
// @next Failure
type EthereumVerifyMessage struct {
	Address          []byte `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Signature        []byte `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	Message          []byte `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *EthereumVerifyMessage) Reset()                    { *m = EthereumVerifyMessage{} }
func (m *EthereumVerifyMessage) String() string            { return proto.CompactTextString(m) }
func (*EthereumVerifyMessage) ProtoMessage()               {}
func (*EthereumVerifyMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *EthereumVerifyMessage) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *EthereumVerifyMessage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *EthereumVerifyMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func init() {
	proto.RegisterType((*EthereumGetPublicKey)(nil), "hw.trezor.messages.ethereum.EthereumGetPublicKey")
	proto.RegisterType((*EthereumPublicKey)(nil), "hw.trezor.messages.ethereum.EthereumPublicKey")
	proto.RegisterType((*EthereumGetAddress)(nil), "hw.trezor.messages.ethereum.EthereumGetAddress")
	proto.RegisterType((*EthereumAddress)(nil), "hw.trezor.messages.ethereum.EthereumAddress")
	proto.RegisterType((*EthereumSignTx)(nil), "hw.trezor.messages.ethereum.EthereumSignTx")
	proto.RegisterType((*EthereumTxRequest)(nil), "hw.trezor.messages.ethereum.EthereumTxRequest")
	proto.RegisterType((*EthereumTxAck)(nil), "hw.trezor.messages.ethereum.EthereumTxAck")
	proto.RegisterType((*EthereumSignMessage)(nil), "hw.trezor.messages.ethereum.EthereumSignMessage")
	proto.RegisterType((*EthereumMessageSignature)(nil), "hw.trezor.messages.ethereum.EthereumMessageSignature")
	proto.RegisterType((*EthereumVerifyMessage)(nil), "hw.trezor.messages.ethereum.EthereumVerifyMessage")
}

func init() { proto.RegisterFile("messages-ethereum.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 577 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x95, 0xd3, 0x8f, 0x24, 0x93, 0xa4, 0xc0, 0xd2, 0xaa, 0x0b, 0x05, 0x35, 0x18, 0x21, 0x45,
	0x02, 0x7c, 0xe0, 0x86, 0xc4, 0xa5, 0xa5, 0x08, 0x2a, 0x4a, 0x55, 0x6d, 0xa2, 0x5e, 0xad, 0xb5,
	0xbd, 0xb5, 0x57, 0xb5, 0xbd, 0xae, 0x77, 0xdd, 0x26, 0xfc, 0x11, 0xfe, 0x01, 0xbf, 0x13, 0x79,
	0xbd, 0x1b, 0x27, 0x80, 0x7a, 0x80, 0x5b, 0xe6, 0xcd, 0x9b, 0x37, 0x6f, 0x67, 0x26, 0x86, 0xfd,
	0x8c, 0x49, 0x49, 0x63, 0x26, 0xdf, 0x32, 0x95, 0xb0, 0x92, 0x55, 0x99, 0x57, 0x94, 0x42, 0x09,
	0x74, 0x90, 0xdc, 0x79, 0xaa, 0x64, 0xdf, 0x45, 0xe9, 0x59, 0x8a, 0x67, 0x29, 0x4f, 0xf7, 0x96,
	0x55, 0xa1, 0xc8, 0x32, 0x91, 0x37, 0x35, 0xee, 0x0d, 0xec, 0x7e, 0x32, 0x94, 0xcf, 0x4c, 0x5d,
	0x54, 0x41, 0xca, 0xc3, 0xaf, 0x6c, 0x81, 0x0e, 0xa0, 0x4f, 0xa3, 0xa8, 0x64, 0x52, 0xfa, 0x39,
	0x76, 0xc6, 0x1b, 0x93, 0x11, 0xe9, 0x19, 0xe0, 0x1c, 0xbd, 0x80, 0xa1, 0x4c, 0xc4, 0x9d, 0x1f,
	0x71, 0x59, 0xa4, 0x74, 0x81, 0x3b, 0x63, 0x67, 0xd2, 0x23, 0x83, 0x1a, 0x3b, 0x69, 0x20, 0xf4,
	0x04, 0x7a, 0x61, 0x42, 0x79, 0xee, 0xf3, 0x08, 0x6f, 0x8c, 0x9d, 0xc9, 0x88, 0x74, 0x75, 0x7c,
	0x1a, 0xb9, 0x01, 0x3c, 0xb2, 0x2d, 0xdb, 0x7e, 0xef, 0x61, 0x33, 0x17, 0x11, 0xc3, 0xce, 0xb8,
	0x33, 0x19, 0xbc, 0x7b, 0xe5, 0xfd, 0xe5, 0x29, 0xc6, 0xf7, 0x97, 0x93, 0x73, 0x11, 0xb1, 0xd9,
	0xa2, 0x60, 0x44, 0x97, 0x20, 0x04, 0x9b, 0xf3, 0xa2, 0x0a, 0xb4, 0x8b, 0x3e, 0xd1, 0xbf, 0xdd,
	0x19, 0xa0, 0x95, 0x67, 0x1d, 0x35, 0xc6, 0xff, 0xf7, 0x51, 0xee, 0x6b, 0x78, 0x60, 0x55, 0xad,
	0x24, 0x86, 0xae, 0x51, 0xd0, 0xd6, 0x87, 0xc4, 0x86, 0xee, 0xcf, 0x0e, 0xec, 0x58, 0xf6, 0x94,
	0xc7, 0xf9, 0x6c, 0x7e, 0x7f, 0xff, 0x5d, 0xd8, 0xca, 0x45, 0x1e, 0x32, 0xdd, 0x78, 0x48, 0x9a,
	0xa0, 0x2e, 0x89, 0xa9, 0xf4, 0x8b, 0x92, 0x87, 0x4c, 0x0f, 0x72, 0x48, 0x7a, 0x31, 0x95, 0x17,
	0x75, 0x6c, 0x93, 0x29, 0xcf, 0xb8, 0xc2, 0x9b, 0xcb, 0xe4, 0x59, 0x1d, 0xa3, 0x1d, 0xe8, 0x28,
	0x81, 0xb7, 0x34, 0xda, 0x51, 0xa2, 0xd6, 0xbf, 0xa5, 0x69, 0xc5, 0xf0, 0x76, 0xa3, 0xaf, 0x03,
	0xf4, 0x06, 0x50, 0x44, 0x15, 0xf5, 0x79, 0xce, 0x15, 0xa7, 0xa9, 0x1f, 0x26, 0x55, 0x7e, 0x8d,
	0xbb, 0x9a, 0xf2, 0xb0, 0xce, 0x9c, 0x36, 0x89, 0x8f, 0x35, 0x8e, 0x0e, 0x61, 0xa0, 0xd9, 0x29,
	0xcb, 0x63, 0x95, 0xe0, 0x9e, 0x5e, 0x2c, 0xd4, 0xd0, 0x99, 0x46, 0xd6, 0xd6, 0xde, 0x5f, 0x5b,
	0x3b, 0xda, 0x87, 0xae, 0x9a, 0xfb, 0x6a, 0x51, 0x30, 0x0c, 0x3a, 0xb3, 0xad, 0xe6, 0xf5, 0x16,
	0xdd, 0x1f, 0x4e, 0x7b, 0x10, 0xb3, 0x39, 0x61, 0x37, 0x15, 0x93, 0xea, 0xf7, 0x56, 0xce, 0x1f,
	0xad, 0x0e, 0x61, 0x20, 0x79, 0x9c, 0x53, 0x55, 0x95, 0xcc, 0xbf, 0xd5, 0x53, 0x1b, 0x11, 0x58,
	0x42, 0x97, 0xeb, 0x84, 0xd2, 0x0c, 0xaf, 0x25, 0x90, 0x75, 0x82, 0x34, 0x03, 0x6c, 0x09, 0x53,
	0xd7, 0x83, 0x51, 0x6b, 0xec, 0x28, 0xbc, 0x46, 0xcf, 0x41, 0x3b, 0x30, 0x53, 0x72, 0x74, 0x41,
	0xbf, 0x46, 0xf4, 0x78, 0xdc, 0x33, 0x78, 0xbc, 0xba, 0xf1, 0x6f, 0xcd, 0xe5, 0xde, 0xbf, 0x76,
	0x0c, 0x5d, 0x73, 0xe1, 0xb8, 0xd3, 0x1c, 0x90, 0x09, 0x5d, 0x02, 0xd8, 0xaa, 0x19, 0xa5, 0xa9,
	0xb5, 0xb6, 0x7e, 0x76, 0xce, 0xca, 0xd9, 0xa1, 0x67, 0xd0, 0x5f, 0xbe, 0xc0, 0x9c, 0x52, 0x0b,
	0xb8, 0x1c, 0xf6, 0xac, 0xe6, 0x25, 0x2b, 0xf9, 0xd5, 0xc2, 0x7a, 0xfc, 0x47, 0xc1, 0x55, 0xfb,
	0xcd, 0x80, 0x6d, 0x78, 0xfc, 0x01, 0x5e, 0x86, 0x22, 0xf3, 0x24, 0x55, 0x42, 0x26, 0x3c, 0xa5,
	0x81, 0xb4, 0xff, 0xe8, 0x94, 0x07, 0xcd, 0xd7, 0x27, 0xa8, 0xae, 0x8e, 0xf7, 0x66, 0x1a, 0x34,
	0x3e, 0xac, 0xb9, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1e, 0xac, 0x9c, 0x5a, 0xe5, 0x04, 0x00,
	0x00,
}
